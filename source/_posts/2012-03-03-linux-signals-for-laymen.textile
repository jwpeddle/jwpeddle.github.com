---
layout: post
title: "Linux Signals for Laymen"
date: 2012-03-03 05:10
comments: true
categories: linux
---
SIGKILL, SIGTERM, SIGHUP, SIGINT. These terms might be second nature to seasoned *nix veterans, but if you're a casual Linux user like me, these might look scary robot language words. Turns out they're actually a pretty simple concept, and you probably use them all the time without even knowing it.

I'm sure most terminal-savvy Linux users have had to use @ps | grep@ to find an uppity process, then @kill@ to shut it down it. Oh, and if it that doesn't work, there's the super duper method, @kill -9@. I assumed that meant "kill this 9 deaths at once". I wasn't far off, but kill is more of a message delivery system-- not the aggressive killbot its name might imply.

You see, when you fire up a Linux process, even if there's no GUI to interact with, you can still talk to it. For example, let's say you have Apache running in the background and you want to shut it down. One common way to do this is by calling @apache2ctl stop@. But what does that actually do? How does this new process make another unrelated process shutdown? How is it different from how nginx shuts down, or mysql? Or even @tail -f@? Turns out, they all essentially shut down the same way. They receive _signals_.

According to the "Apache docs":http://httpd.apache.org/docs/2.0/stopping.html, calling @apache2ctl stop@ uses the signal *TERM* (terminate). Basically, apache2ctl sends a message to apache saying "terminate!" and apache responds to this message by shutting itself down.

To restart apache with @apache2ctl restart@, you're sending the *HUP* signal. HUP stands for "hang up", but this metaphor is not really relevant anymore. Usually it means "reread your configuration files". apache2ctl has another type of restart with the @apache2ctl graceful@ command, which sends the signal *USR1*. This one doesn't have any inherent meaning. They likely chose it because none of the other signals seemed appropriate. In apache's case, they try to reload configuration files without killing anyone currently accessing the site. What a process does in response to a signal is up to the process (usually). Nginx uses the HUP signal too, for example, but it reacts more of like apache does when it receives USR1 - it restarts _gracefully_.

So what does this have to do with kill?
kill isn't just intended to violently end processes. It is used to send _all_ signals in a simple, direct, way. Calling @kill apache@ sends the TERM signal, just like @apache2ctl stop@ does! And if is doesn't shutdown after that: @kill -9@ sends the *KILL* signal, which also shuts down apache, but in a more aggressive way-- the apache process gets no say. It just immediately dies, end of story. Why -9? 9 is just an alias for KILL. Run @kill -l@ and you'll see all the number aliases and signals that can be sent. kill can also just use the signals name directly. @kill@ is the same as @kill -TERM@, which is the same as @kill -15@.

There are "many signals":http://en.wikipedia.org/wiki/Signal_(computing), most of which are some variation of "shut down". Some only apply to programs running in a terminal: if you've ever used _ctrl-c_ to shutdown a process running in the terminal, you've sent *INT* (interrupt) signal! Kinda like TERM, but only for the terminal. Likewise, if you press ctrl-z, you send *TSTP* (tty/terminal stop) which pauses your process in the background. You can confirm this by running @jobs@, then resume it again by running @fg@, which once again sends a signal: *CONT* (continue). This was especially enlightening to me because I thought ctrl-z was more akin to @kill -9@. I have to wonder how many processes I've stuffed into the background of my terminals from misusing this shortcut.

I suspect this post is old hat to a lot of users, but I've been using Linux for years and had no concept of signals. Reading up on it instantly made years of being confused by processes make sense. I can only hope some confused googler wanders past here and gets the same benefit.