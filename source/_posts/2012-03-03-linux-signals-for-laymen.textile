---
layout: post
title: "Linux Signals for Laymen"
date: 2012-03-03 05:10
comments: true
categories: linux
---
SIGKILL, SIGTERM, SIGHUP, SIGINT. If you're a casual Linux user or web dev like me, these might look scary robot language words. Turns out they're actually pretty important, and you probably use them all the time without even knowing it.

I'm sure most terminal-savvy Linux users have had to use @ps | grep@ to find an uppity process, then @kill@ to shut it down it. Oh, and if it that doesn't work, there's the super duper method, @kill -9@. I assumed that meant "kill this 9 deaths at once". Turns out, kill is more of a message delivery system-- not the aggressive killbot its name might imply.

You see, when you fire up a Linux process, even if there's no GUI to interact with, you can still talk to it. For example, let's say you have Apache running in the background and you want to shut it down. One common way to do this is by calling @apache2ctl stop@. But what does that actually do? How does this new process make another unrelated process shutdown? How is it different from how nginx shuts down, or mysql? Or even @tail -f@? Turns out, they all essentially shut down the same way. They receive _signals_.

According to the "Apache docs":http://httpd.apache.org/docs/2.0/stopping.html, calling @apache2ctl@ stop sends the signal *TERM* (terminate) to the apache process. So basically, apache2ctl tells apache "terminate!" and apache responds to this message by shutting itself down.

To restart apache with @apache2ctl restart@, you're sending the *HUP* signal. HUP stands for "hangup", but this metaphor is not really relevant anymore. Usually it means "reread your configuration files". apace2ctl has another type of restart with the _graceful_ command, which sends the signal *USR1*. This one doesn't have any inherent meaning. They likely chose it because none of the other signals seemed appropriate. In apache's case, they try to reload configuration files without killing anyone currently accessing the site.

What a process does in response to a signal is up to the process. nginx uses the HUP signal too, for example, but they use it like Apache uses USR1 - to mean "restart gracefully".

So what does this have to do with kill?
kill isn't just intended to violently end processes. It is used to send _all_ signals in a simple, direct, way. Calling @kill apache@ sends the TERM signal, just like @apache2ctl stop@ does! And if is doesn't shutdown after that: @kill -9@ sends the *KILL* signal, which also shuts down apache, but in a more aggressive way-- the apache process gets no say. It just immediately dies, end of story. Why -9? 9 is just an alias for KILL. Run @kill -l@ and you'll see all the number aliases and signals that can be sent. kill can also just use the signals name directly. For example: @kill@ == @kill -TERM@ == @kill -15@.

There are "many signals":http://en.wikipedia.org/wiki/Signal_(computing), most of which are some variation of "shut down". Some only make sense when the program is running in a terminal. If you've ever used _ctrl-c_ to shutdown a process running in the terminal, it turns out you're sending the INT (interrupt) signal. This is kinda like TERM, but for things running in a terminal. Likewise, if you press ctrl-z, you send *TSTP* (tty/terminal stop) which pauses your process in the background. You can confirm this by running @jobs@, then resume it again by running @fg@, which once again sends a signal: *CONT* (continue).